== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#27)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=201]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#27)])
         +- Union
            :- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#19)])
            :  +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=188]
            :     +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#19)])
            :        +- FileScan csv [edge_1#17,edge_2#18,length#19] Batched: false, DataFilters: [], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_0.csv], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
            +- Project [edge_1#81, edge_2#59, (length#27 + length#61) AS length#77]
               +- BroadcastHashJoin [edge_2#82], [edge_1#58], Inner, BuildRight, false
                  :- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[min(length#83)])
                  :  +- Exchange hashpartitioning(edge_1#81, edge_2#82, 200), ENSURE_REQUIREMENTS, [plan_id=190]
                  :     +- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[partial_min(length#83)])
                  :        +- Filter ((edge_2#82 = 0) AND isnotnull(edge_2#82))
                  :           +- FileScan csv [edge_1#81,edge_2#82,length#83] Batched: false, DataFilters: [(edge_2#82 = 0), isnotnull(edge_2#82)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_0.csv], PartitionFilters: [], PushedFilters: [EqualTo(edge_2,0), IsNotNull(edge_2)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, true] as bigint)),false), [plan_id=195]
                     +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[min(length#60)])
                        +- Exchange hashpartitioning(edge_1#58, edge_2#59, 200), ENSURE_REQUIREMENTS, [plan_id=192]
                           +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[partial_min(length#60)])
                              +- Filter (isnotnull(edge_1#58) AND (edge_1#58 = 0))
                                 +- FileScan csv [edge_1#58,edge_2#59,length#60] Batched: false, DataFilters: [isnotnull(edge_1#58), (edge_1#58 = 0)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_0.csv], PartitionFilters: [], PushedFilters: [IsNotNull(edge_1), EqualTo(edge_1,0)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>


0
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#92)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=536]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#92)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#92]
            +- Project [edge_1#152, edge_2#132, (length#154 + length#133) AS length#148]
               +- BroadcastHashJoin [edge_2#153], [edge_1#131], Inner, BuildRight, false
                  :- Filter ((edge_2#153 = 1) AND isnotnull(edge_2#153))
                  :  +- Scan ExistingRDD[edge_1#152,edge_2#153,length#154]
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=530]
                     +- Filter (isnotnull(edge_1#131) AND (edge_1#131 = 1))
                        +- Scan ExistingRDD[edge_1#131,edge_2#132,length#133]


1
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#162)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=682]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#162)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#162]
            +- Project [edge_1#195, edge_2#175, (length#197 + length#176) AS length#191]
               +- SortMergeJoin [edge_2#196], [edge_1#174], Inner
                  :- Sort [edge_2#196 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#196, 200), ENSURE_REQUIREMENTS, [plan_id=673]
                  :     +- Filter ((edge_2#196 = 2) AND isnotnull(edge_2#196))
                  :        +- Scan ExistingRDD[edge_1#195,edge_2#196,length#197]
                  +- Sort [edge_1#174 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#174, 200), ENSURE_REQUIREMENTS, [plan_id=674]
                        +- Filter (isnotnull(edge_1#174) AND (edge_1#174 = 2))
                           +- Scan ExistingRDD[edge_1#174,edge_2#175,length#176]


2
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#205)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=909]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#205)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#205]
            +- Project [edge_1#238, edge_2#218, (length#240 + length#219) AS length#234]
               +- SortMergeJoin [edge_2#239], [edge_1#217], Inner
                  :- Sort [edge_2#239 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#239, 200), ENSURE_REQUIREMENTS, [plan_id=900]
                  :     +- Filter ((edge_2#239 = 3) AND isnotnull(edge_2#239))
                  :        +- Scan ExistingRDD[edge_1#238,edge_2#239,length#240]
                  +- Sort [edge_1#217 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#217, 200), ENSURE_REQUIREMENTS, [plan_id=901]
                        +- Filter (isnotnull(edge_1#217) AND (edge_1#217 = 3))
                           +- Scan ExistingRDD[edge_1#217,edge_2#218,length#219]


3
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#248)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1136]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#248)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#248]
            +- Project [edge_1#281, edge_2#261, (length#283 + length#262) AS length#277]
               +- SortMergeJoin [edge_2#282], [edge_1#260], Inner
                  :- Sort [edge_2#282 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#282, 200), ENSURE_REQUIREMENTS, [plan_id=1127]
                  :     +- Filter ((edge_2#282 = 4) AND isnotnull(edge_2#282))
                  :        +- Scan ExistingRDD[edge_1#281,edge_2#282,length#283]
                  +- Sort [edge_1#260 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#260, 200), ENSURE_REQUIREMENTS, [plan_id=1128]
                        +- Filter (isnotnull(edge_1#260) AND (edge_1#260 = 4))
                           +- Scan ExistingRDD[edge_1#260,edge_2#261,length#262]


4
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#291)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1363]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#291)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#291]
            +- Project [edge_1#324, edge_2#304, (length#326 + length#305) AS length#320]
               +- SortMergeJoin [edge_2#325], [edge_1#303], Inner
                  :- Sort [edge_2#325 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#325, 200), ENSURE_REQUIREMENTS, [plan_id=1354]
                  :     +- Filter ((edge_2#325 = 5) AND isnotnull(edge_2#325))
                  :        +- Scan ExistingRDD[edge_1#324,edge_2#325,length#326]
                  +- Sort [edge_1#303 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#303, 200), ENSURE_REQUIREMENTS, [plan_id=1355]
                        +- Filter (isnotnull(edge_1#303) AND (edge_1#303 = 5))
                           +- Scan ExistingRDD[edge_1#303,edge_2#304,length#305]


5
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#334)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1590]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#334)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#334]
            +- Project [edge_1#367, edge_2#347, (length#369 + length#348) AS length#363]
               +- SortMergeJoin [edge_2#368], [edge_1#346], Inner
                  :- Sort [edge_2#368 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#368, 200), ENSURE_REQUIREMENTS, [plan_id=1581]
                  :     +- Filter ((edge_2#368 = 6) AND isnotnull(edge_2#368))
                  :        +- Scan ExistingRDD[edge_1#367,edge_2#368,length#369]
                  +- Sort [edge_1#346 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#346, 200), ENSURE_REQUIREMENTS, [plan_id=1582]
                        +- Filter (isnotnull(edge_1#346) AND (edge_1#346 = 6))
                           +- Scan ExistingRDD[edge_1#346,edge_2#347,length#348]


6
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#377)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1817]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#377)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#377]
            +- Project [edge_1#410, edge_2#390, (length#412 + length#391) AS length#406]
               +- SortMergeJoin [edge_2#411], [edge_1#389], Inner
                  :- Sort [edge_2#411 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#411, 200), ENSURE_REQUIREMENTS, [plan_id=1808]
                  :     +- Filter ((edge_2#411 = 7) AND isnotnull(edge_2#411))
                  :        +- Scan ExistingRDD[edge_1#410,edge_2#411,length#412]
                  +- Sort [edge_1#389 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#389, 200), ENSURE_REQUIREMENTS, [plan_id=1809]
                        +- Filter (isnotnull(edge_1#389) AND (edge_1#389 = 7))
                           +- Scan ExistingRDD[edge_1#389,edge_2#390,length#391]


7
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#420)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2044]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#420)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#420]
            +- Project [edge_1#453, edge_2#433, (length#455 + length#434) AS length#449]
               +- SortMergeJoin [edge_2#454], [edge_1#432], Inner
                  :- Sort [edge_2#454 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#454, 200), ENSURE_REQUIREMENTS, [plan_id=2035]
                  :     +- Filter ((edge_2#454 = 8) AND isnotnull(edge_2#454))
                  :        +- Scan ExistingRDD[edge_1#453,edge_2#454,length#455]
                  +- Sort [edge_1#432 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#432, 200), ENSURE_REQUIREMENTS, [plan_id=2036]
                        +- Filter (isnotnull(edge_1#432) AND (edge_1#432 = 8))
                           +- Scan ExistingRDD[edge_1#432,edge_2#433,length#434]


8
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#463)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2271]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#463)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#463]
            +- Project [edge_1#496, edge_2#476, (length#498 + length#477) AS length#492]
               +- SortMergeJoin [edge_2#497], [edge_1#475], Inner
                  :- Sort [edge_2#497 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#497, 200), ENSURE_REQUIREMENTS, [plan_id=2262]
                  :     +- Filter ((edge_2#497 = 9) AND isnotnull(edge_2#497))
                  :        +- Scan ExistingRDD[edge_1#496,edge_2#497,length#498]
                  +- Sort [edge_1#475 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#475, 200), ENSURE_REQUIREMENTS, [plan_id=2263]
                        +- Filter (isnotnull(edge_1#475) AND (edge_1#475 = 9))
                           +- Scan ExistingRDD[edge_1#475,edge_2#476,length#477]


9
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#27)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=201]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#27)])
         +- Union
            :- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#19)])
            :  +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=188]
            :     +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#19)])
            :        +- FileScan csv [edge_1#17,edge_2#18,length#19] Batched: false, DataFilters: [], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_1.csv], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
            +- Project [edge_1#81, edge_2#59, (length#27 + length#61) AS length#77]
               +- BroadcastHashJoin [edge_2#82], [edge_1#58], Inner, BuildRight, false
                  :- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[min(length#83)])
                  :  +- Exchange hashpartitioning(edge_1#81, edge_2#82, 200), ENSURE_REQUIREMENTS, [plan_id=190]
                  :     +- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[partial_min(length#83)])
                  :        +- Filter ((edge_2#82 = 0) AND isnotnull(edge_2#82))
                  :           +- FileScan csv [edge_1#81,edge_2#82,length#83] Batched: false, DataFilters: [(edge_2#82 = 0), isnotnull(edge_2#82)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_1.csv], PartitionFilters: [], PushedFilters: [EqualTo(edge_2,0), IsNotNull(edge_2)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, true] as bigint)),false), [plan_id=195]
                     +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[min(length#60)])
                        +- Exchange hashpartitioning(edge_1#58, edge_2#59, 200), ENSURE_REQUIREMENTS, [plan_id=192]
                           +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[partial_min(length#60)])
                              +- Filter (isnotnull(edge_1#58) AND (edge_1#58 = 0))
                                 +- FileScan csv [edge_1#58,edge_2#59,length#60] Batched: false, DataFilters: [isnotnull(edge_1#58), (edge_1#58 = 0)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_1.csv], PartitionFilters: [], PushedFilters: [IsNotNull(edge_1), EqualTo(edge_1,0)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>


0
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#92)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=536]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#92)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#92]
            +- Project [edge_1#152, edge_2#132, (length#154 + length#133) AS length#148]
               +- BroadcastHashJoin [edge_2#153], [edge_1#131], Inner, BuildRight, false
                  :- Filter ((edge_2#153 = 1) AND isnotnull(edge_2#153))
                  :  +- Scan ExistingRDD[edge_1#152,edge_2#153,length#154]
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=530]
                     +- Filter (isnotnull(edge_1#131) AND (edge_1#131 = 1))
                        +- Scan ExistingRDD[edge_1#131,edge_2#132,length#133]


1
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#162)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=682]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#162)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#162]
            +- Project [edge_1#195, edge_2#175, (length#197 + length#176) AS length#191]
               +- SortMergeJoin [edge_2#196], [edge_1#174], Inner
                  :- Sort [edge_2#196 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#196, 200), ENSURE_REQUIREMENTS, [plan_id=673]
                  :     +- Filter ((edge_2#196 = 2) AND isnotnull(edge_2#196))
                  :        +- Scan ExistingRDD[edge_1#195,edge_2#196,length#197]
                  +- Sort [edge_1#174 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#174, 200), ENSURE_REQUIREMENTS, [plan_id=674]
                        +- Filter (isnotnull(edge_1#174) AND (edge_1#174 = 2))
                           +- Scan ExistingRDD[edge_1#174,edge_2#175,length#176]


2
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#205)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=909]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#205)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#205]
            +- Project [edge_1#238, edge_2#218, (length#240 + length#219) AS length#234]
               +- SortMergeJoin [edge_2#239], [edge_1#217], Inner
                  :- Sort [edge_2#239 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#239, 200), ENSURE_REQUIREMENTS, [plan_id=900]
                  :     +- Filter ((edge_2#239 = 3) AND isnotnull(edge_2#239))
                  :        +- Scan ExistingRDD[edge_1#238,edge_2#239,length#240]
                  +- Sort [edge_1#217 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#217, 200), ENSURE_REQUIREMENTS, [plan_id=901]
                        +- Filter (isnotnull(edge_1#217) AND (edge_1#217 = 3))
                           +- Scan ExistingRDD[edge_1#217,edge_2#218,length#219]


3
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#248)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1136]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#248)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#248]
            +- Project [edge_1#281, edge_2#261, (length#283 + length#262) AS length#277]
               +- SortMergeJoin [edge_2#282], [edge_1#260], Inner
                  :- Sort [edge_2#282 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#282, 200), ENSURE_REQUIREMENTS, [plan_id=1127]
                  :     +- Filter ((edge_2#282 = 4) AND isnotnull(edge_2#282))
                  :        +- Scan ExistingRDD[edge_1#281,edge_2#282,length#283]
                  +- Sort [edge_1#260 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#260, 200), ENSURE_REQUIREMENTS, [plan_id=1128]
                        +- Filter (isnotnull(edge_1#260) AND (edge_1#260 = 4))
                           +- Scan ExistingRDD[edge_1#260,edge_2#261,length#262]


4
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#291)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1363]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#291)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#291]
            +- Project [edge_1#324, edge_2#304, (length#326 + length#305) AS length#320]
               +- SortMergeJoin [edge_2#325], [edge_1#303], Inner
                  :- Sort [edge_2#325 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#325, 200), ENSURE_REQUIREMENTS, [plan_id=1354]
                  :     +- Filter ((edge_2#325 = 5) AND isnotnull(edge_2#325))
                  :        +- Scan ExistingRDD[edge_1#324,edge_2#325,length#326]
                  +- Sort [edge_1#303 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#303, 200), ENSURE_REQUIREMENTS, [plan_id=1355]
                        +- Filter (isnotnull(edge_1#303) AND (edge_1#303 = 5))
                           +- Scan ExistingRDD[edge_1#303,edge_2#304,length#305]


5
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#334)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1590]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#334)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#334]
            +- Project [edge_1#367, edge_2#347, (length#369 + length#348) AS length#363]
               +- SortMergeJoin [edge_2#368], [edge_1#346], Inner
                  :- Sort [edge_2#368 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#368, 200), ENSURE_REQUIREMENTS, [plan_id=1581]
                  :     +- Filter ((edge_2#368 = 6) AND isnotnull(edge_2#368))
                  :        +- Scan ExistingRDD[edge_1#367,edge_2#368,length#369]
                  +- Sort [edge_1#346 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#346, 200), ENSURE_REQUIREMENTS, [plan_id=1582]
                        +- Filter (isnotnull(edge_1#346) AND (edge_1#346 = 6))
                           +- Scan ExistingRDD[edge_1#346,edge_2#347,length#348]


6
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#377)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1817]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#377)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#377]
            +- Project [edge_1#410, edge_2#390, (length#412 + length#391) AS length#406]
               +- SortMergeJoin [edge_2#411], [edge_1#389], Inner
                  :- Sort [edge_2#411 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#411, 200), ENSURE_REQUIREMENTS, [plan_id=1808]
                  :     +- Filter ((edge_2#411 = 7) AND isnotnull(edge_2#411))
                  :        +- Scan ExistingRDD[edge_1#410,edge_2#411,length#412]
                  +- Sort [edge_1#389 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#389, 200), ENSURE_REQUIREMENTS, [plan_id=1809]
                        +- Filter (isnotnull(edge_1#389) AND (edge_1#389 = 7))
                           +- Scan ExistingRDD[edge_1#389,edge_2#390,length#391]


7
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#420)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2044]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#420)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#420]
            +- Project [edge_1#453, edge_2#433, (length#455 + length#434) AS length#449]
               +- SortMergeJoin [edge_2#454], [edge_1#432], Inner
                  :- Sort [edge_2#454 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#454, 200), ENSURE_REQUIREMENTS, [plan_id=2035]
                  :     +- Filter ((edge_2#454 = 8) AND isnotnull(edge_2#454))
                  :        +- Scan ExistingRDD[edge_1#453,edge_2#454,length#455]
                  +- Sort [edge_1#432 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#432, 200), ENSURE_REQUIREMENTS, [plan_id=2036]
                        +- Filter (isnotnull(edge_1#432) AND (edge_1#432 = 8))
                           +- Scan ExistingRDD[edge_1#432,edge_2#433,length#434]


8
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#463)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2271]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#463)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#463]
            +- Project [edge_1#496, edge_2#476, (length#498 + length#477) AS length#492]
               +- SortMergeJoin [edge_2#497], [edge_1#475], Inner
                  :- Sort [edge_2#497 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#497, 200), ENSURE_REQUIREMENTS, [plan_id=2262]
                  :     +- Filter ((edge_2#497 = 9) AND isnotnull(edge_2#497))
                  :        +- Scan ExistingRDD[edge_1#496,edge_2#497,length#498]
                  +- Sort [edge_1#475 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#475, 200), ENSURE_REQUIREMENTS, [plan_id=2263]
                        +- Filter (isnotnull(edge_1#475) AND (edge_1#475 = 9))
                           +- Scan ExistingRDD[edge_1#475,edge_2#476,length#477]


9
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#27)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=201]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#27)])
         +- Union
            :- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#19)])
            :  +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=188]
            :     +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#19)])
            :        +- FileScan csv [edge_1#17,edge_2#18,length#19] Batched: false, DataFilters: [], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_2.csv], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
            +- Project [edge_1#81, edge_2#59, (length#27 + length#61) AS length#77]
               +- BroadcastHashJoin [edge_2#82], [edge_1#58], Inner, BuildRight, false
                  :- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[min(length#83)])
                  :  +- Exchange hashpartitioning(edge_1#81, edge_2#82, 200), ENSURE_REQUIREMENTS, [plan_id=190]
                  :     +- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[partial_min(length#83)])
                  :        +- Filter ((edge_2#82 = 0) AND isnotnull(edge_2#82))
                  :           +- FileScan csv [edge_1#81,edge_2#82,length#83] Batched: false, DataFilters: [(edge_2#82 = 0), isnotnull(edge_2#82)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_2.csv], PartitionFilters: [], PushedFilters: [EqualTo(edge_2,0), IsNotNull(edge_2)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, true] as bigint)),false), [plan_id=195]
                     +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[min(length#60)])
                        +- Exchange hashpartitioning(edge_1#58, edge_2#59, 200), ENSURE_REQUIREMENTS, [plan_id=192]
                           +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[partial_min(length#60)])
                              +- Filter (isnotnull(edge_1#58) AND (edge_1#58 = 0))
                                 +- FileScan csv [edge_1#58,edge_2#59,length#60] Batched: false, DataFilters: [isnotnull(edge_1#58), (edge_1#58 = 0)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_2.csv], PartitionFilters: [], PushedFilters: [IsNotNull(edge_1), EqualTo(edge_1,0)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>


0
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#92)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=536]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#92)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#92]
            +- Project [edge_1#152, edge_2#132, (length#154 + length#133) AS length#148]
               +- BroadcastHashJoin [edge_2#153], [edge_1#131], Inner, BuildRight, false
                  :- Filter ((edge_2#153 = 1) AND isnotnull(edge_2#153))
                  :  +- Scan ExistingRDD[edge_1#152,edge_2#153,length#154]
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=530]
                     +- Filter (isnotnull(edge_1#131) AND (edge_1#131 = 1))
                        +- Scan ExistingRDD[edge_1#131,edge_2#132,length#133]


1
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#162)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=682]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#162)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#162]
            +- Project [edge_1#195, edge_2#175, (length#197 + length#176) AS length#191]
               +- SortMergeJoin [edge_2#196], [edge_1#174], Inner
                  :- Sort [edge_2#196 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#196, 200), ENSURE_REQUIREMENTS, [plan_id=673]
                  :     +- Filter ((edge_2#196 = 2) AND isnotnull(edge_2#196))
                  :        +- Scan ExistingRDD[edge_1#195,edge_2#196,length#197]
                  +- Sort [edge_1#174 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#174, 200), ENSURE_REQUIREMENTS, [plan_id=674]
                        +- Filter (isnotnull(edge_1#174) AND (edge_1#174 = 2))
                           +- Scan ExistingRDD[edge_1#174,edge_2#175,length#176]


2
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#205)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=909]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#205)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#205]
            +- Project [edge_1#238, edge_2#218, (length#240 + length#219) AS length#234]
               +- SortMergeJoin [edge_2#239], [edge_1#217], Inner
                  :- Sort [edge_2#239 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#239, 200), ENSURE_REQUIREMENTS, [plan_id=900]
                  :     +- Filter ((edge_2#239 = 3) AND isnotnull(edge_2#239))
                  :        +- Scan ExistingRDD[edge_1#238,edge_2#239,length#240]
                  +- Sort [edge_1#217 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#217, 200), ENSURE_REQUIREMENTS, [plan_id=901]
                        +- Filter (isnotnull(edge_1#217) AND (edge_1#217 = 3))
                           +- Scan ExistingRDD[edge_1#217,edge_2#218,length#219]


3
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#248)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1136]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#248)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#248]
            +- Project [edge_1#281, edge_2#261, (length#283 + length#262) AS length#277]
               +- SortMergeJoin [edge_2#282], [edge_1#260], Inner
                  :- Sort [edge_2#282 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#282, 200), ENSURE_REQUIREMENTS, [plan_id=1127]
                  :     +- Filter ((edge_2#282 = 4) AND isnotnull(edge_2#282))
                  :        +- Scan ExistingRDD[edge_1#281,edge_2#282,length#283]
                  +- Sort [edge_1#260 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#260, 200), ENSURE_REQUIREMENTS, [plan_id=1128]
                        +- Filter (isnotnull(edge_1#260) AND (edge_1#260 = 4))
                           +- Scan ExistingRDD[edge_1#260,edge_2#261,length#262]


4
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#291)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1363]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#291)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#291]
            +- Project [edge_1#324, edge_2#304, (length#326 + length#305) AS length#320]
               +- SortMergeJoin [edge_2#325], [edge_1#303], Inner
                  :- Sort [edge_2#325 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#325, 200), ENSURE_REQUIREMENTS, [plan_id=1354]
                  :     +- Filter ((edge_2#325 = 5) AND isnotnull(edge_2#325))
                  :        +- Scan ExistingRDD[edge_1#324,edge_2#325,length#326]
                  +- Sort [edge_1#303 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#303, 200), ENSURE_REQUIREMENTS, [plan_id=1355]
                        +- Filter (isnotnull(edge_1#303) AND (edge_1#303 = 5))
                           +- Scan ExistingRDD[edge_1#303,edge_2#304,length#305]


5
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#334)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1590]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#334)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#334]
            +- Project [edge_1#367, edge_2#347, (length#369 + length#348) AS length#363]
               +- SortMergeJoin [edge_2#368], [edge_1#346], Inner
                  :- Sort [edge_2#368 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#368, 200), ENSURE_REQUIREMENTS, [plan_id=1581]
                  :     +- Filter ((edge_2#368 = 6) AND isnotnull(edge_2#368))
                  :        +- Scan ExistingRDD[edge_1#367,edge_2#368,length#369]
                  +- Sort [edge_1#346 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#346, 200), ENSURE_REQUIREMENTS, [plan_id=1582]
                        +- Filter (isnotnull(edge_1#346) AND (edge_1#346 = 6))
                           +- Scan ExistingRDD[edge_1#346,edge_2#347,length#348]


6
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#377)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1817]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#377)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#377]
            +- Project [edge_1#410, edge_2#390, (length#412 + length#391) AS length#406]
               +- SortMergeJoin [edge_2#411], [edge_1#389], Inner
                  :- Sort [edge_2#411 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#411, 200), ENSURE_REQUIREMENTS, [plan_id=1808]
                  :     +- Filter ((edge_2#411 = 7) AND isnotnull(edge_2#411))
                  :        +- Scan ExistingRDD[edge_1#410,edge_2#411,length#412]
                  +- Sort [edge_1#389 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#389, 200), ENSURE_REQUIREMENTS, [plan_id=1809]
                        +- Filter (isnotnull(edge_1#389) AND (edge_1#389 = 7))
                           +- Scan ExistingRDD[edge_1#389,edge_2#390,length#391]


7
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#420)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2044]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#420)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#420]
            +- Project [edge_1#453, edge_2#433, (length#455 + length#434) AS length#449]
               +- SortMergeJoin [edge_2#454], [edge_1#432], Inner
                  :- Sort [edge_2#454 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#454, 200), ENSURE_REQUIREMENTS, [plan_id=2035]
                  :     +- Filter ((edge_2#454 = 8) AND isnotnull(edge_2#454))
                  :        +- Scan ExistingRDD[edge_1#453,edge_2#454,length#455]
                  +- Sort [edge_1#432 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#432, 200), ENSURE_REQUIREMENTS, [plan_id=2036]
                        +- Filter (isnotnull(edge_1#432) AND (edge_1#432 = 8))
                           +- Scan ExistingRDD[edge_1#432,edge_2#433,length#434]


8
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#463)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2271]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#463)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#463]
            +- Project [edge_1#496, edge_2#476, (length#498 + length#477) AS length#492]
               +- SortMergeJoin [edge_2#497], [edge_1#475], Inner
                  :- Sort [edge_2#497 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#497, 200), ENSURE_REQUIREMENTS, [plan_id=2262]
                  :     +- Filter ((edge_2#497 = 9) AND isnotnull(edge_2#497))
                  :        +- Scan ExistingRDD[edge_1#496,edge_2#497,length#498]
                  +- Sort [edge_1#475 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#475, 200), ENSURE_REQUIREMENTS, [plan_id=2263]
                        +- Filter (isnotnull(edge_1#475) AND (edge_1#475 = 9))
                           +- Scan ExistingRDD[edge_1#475,edge_2#476,length#477]


9
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#27)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=201]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#27)])
         +- Union
            :- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#19)])
            :  +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=188]
            :     +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#19)])
            :        +- FileScan csv [edge_1#17,edge_2#18,length#19] Batched: false, DataFilters: [], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_3.csv], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
            +- Project [edge_1#81, edge_2#59, (length#27 + length#61) AS length#77]
               +- BroadcastHashJoin [edge_2#82], [edge_1#58], Inner, BuildRight, false
                  :- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[min(length#83)])
                  :  +- Exchange hashpartitioning(edge_1#81, edge_2#82, 200), ENSURE_REQUIREMENTS, [plan_id=190]
                  :     +- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[partial_min(length#83)])
                  :        +- Filter ((edge_2#82 = 0) AND isnotnull(edge_2#82))
                  :           +- FileScan csv [edge_1#81,edge_2#82,length#83] Batched: false, DataFilters: [(edge_2#82 = 0), isnotnull(edge_2#82)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_3.csv], PartitionFilters: [], PushedFilters: [EqualTo(edge_2,0), IsNotNull(edge_2)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, true] as bigint)),false), [plan_id=195]
                     +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[min(length#60)])
                        +- Exchange hashpartitioning(edge_1#58, edge_2#59, 200), ENSURE_REQUIREMENTS, [plan_id=192]
                           +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[partial_min(length#60)])
                              +- Filter (isnotnull(edge_1#58) AND (edge_1#58 = 0))
                                 +- FileScan csv [edge_1#58,edge_2#59,length#60] Batched: false, DataFilters: [isnotnull(edge_1#58), (edge_1#58 = 0)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_3.csv], PartitionFilters: [], PushedFilters: [IsNotNull(edge_1), EqualTo(edge_1,0)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>


0
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#92)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=536]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#92)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#92]
            +- Project [edge_1#152, edge_2#132, (length#154 + length#133) AS length#148]
               +- BroadcastHashJoin [edge_2#153], [edge_1#131], Inner, BuildRight, false
                  :- Filter ((edge_2#153 = 1) AND isnotnull(edge_2#153))
                  :  +- Scan ExistingRDD[edge_1#152,edge_2#153,length#154]
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=530]
                     +- Filter (isnotnull(edge_1#131) AND (edge_1#131 = 1))
                        +- Scan ExistingRDD[edge_1#131,edge_2#132,length#133]


1
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#162)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=682]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#162)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#162]
            +- Project [edge_1#195, edge_2#175, (length#197 + length#176) AS length#191]
               +- SortMergeJoin [edge_2#196], [edge_1#174], Inner
                  :- Sort [edge_2#196 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#196, 200), ENSURE_REQUIREMENTS, [plan_id=673]
                  :     +- Filter ((edge_2#196 = 2) AND isnotnull(edge_2#196))
                  :        +- Scan ExistingRDD[edge_1#195,edge_2#196,length#197]
                  +- Sort [edge_1#174 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#174, 200), ENSURE_REQUIREMENTS, [plan_id=674]
                        +- Filter (isnotnull(edge_1#174) AND (edge_1#174 = 2))
                           +- Scan ExistingRDD[edge_1#174,edge_2#175,length#176]


2
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#205)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=909]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#205)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#205]
            +- Project [edge_1#238, edge_2#218, (length#240 + length#219) AS length#234]
               +- SortMergeJoin [edge_2#239], [edge_1#217], Inner
                  :- Sort [edge_2#239 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#239, 200), ENSURE_REQUIREMENTS, [plan_id=900]
                  :     +- Filter ((edge_2#239 = 3) AND isnotnull(edge_2#239))
                  :        +- Scan ExistingRDD[edge_1#238,edge_2#239,length#240]
                  +- Sort [edge_1#217 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#217, 200), ENSURE_REQUIREMENTS, [plan_id=901]
                        +- Filter (isnotnull(edge_1#217) AND (edge_1#217 = 3))
                           +- Scan ExistingRDD[edge_1#217,edge_2#218,length#219]


3
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#248)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1136]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#248)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#248]
            +- Project [edge_1#281, edge_2#261, (length#283 + length#262) AS length#277]
               +- SortMergeJoin [edge_2#282], [edge_1#260], Inner
                  :- Sort [edge_2#282 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#282, 200), ENSURE_REQUIREMENTS, [plan_id=1127]
                  :     +- Filter ((edge_2#282 = 4) AND isnotnull(edge_2#282))
                  :        +- Scan ExistingRDD[edge_1#281,edge_2#282,length#283]
                  +- Sort [edge_1#260 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#260, 200), ENSURE_REQUIREMENTS, [plan_id=1128]
                        +- Filter (isnotnull(edge_1#260) AND (edge_1#260 = 4))
                           +- Scan ExistingRDD[edge_1#260,edge_2#261,length#262]


4
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#291)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1363]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#291)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#291]
            +- Project [edge_1#324, edge_2#304, (length#326 + length#305) AS length#320]
               +- SortMergeJoin [edge_2#325], [edge_1#303], Inner
                  :- Sort [edge_2#325 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#325, 200), ENSURE_REQUIREMENTS, [plan_id=1354]
                  :     +- Filter ((edge_2#325 = 5) AND isnotnull(edge_2#325))
                  :        +- Scan ExistingRDD[edge_1#324,edge_2#325,length#326]
                  +- Sort [edge_1#303 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#303, 200), ENSURE_REQUIREMENTS, [plan_id=1355]
                        +- Filter (isnotnull(edge_1#303) AND (edge_1#303 = 5))
                           +- Scan ExistingRDD[edge_1#303,edge_2#304,length#305]


5
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#334)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1590]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#334)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#334]
            +- Project [edge_1#367, edge_2#347, (length#369 + length#348) AS length#363]
               +- SortMergeJoin [edge_2#368], [edge_1#346], Inner
                  :- Sort [edge_2#368 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#368, 200), ENSURE_REQUIREMENTS, [plan_id=1581]
                  :     +- Filter ((edge_2#368 = 6) AND isnotnull(edge_2#368))
                  :        +- Scan ExistingRDD[edge_1#367,edge_2#368,length#369]
                  +- Sort [edge_1#346 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#346, 200), ENSURE_REQUIREMENTS, [plan_id=1582]
                        +- Filter (isnotnull(edge_1#346) AND (edge_1#346 = 6))
                           +- Scan ExistingRDD[edge_1#346,edge_2#347,length#348]


6
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#377)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1817]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#377)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#377]
            +- Project [edge_1#410, edge_2#390, (length#412 + length#391) AS length#406]
               +- SortMergeJoin [edge_2#411], [edge_1#389], Inner
                  :- Sort [edge_2#411 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#411, 200), ENSURE_REQUIREMENTS, [plan_id=1808]
                  :     +- Filter ((edge_2#411 = 7) AND isnotnull(edge_2#411))
                  :        +- Scan ExistingRDD[edge_1#410,edge_2#411,length#412]
                  +- Sort [edge_1#389 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#389, 200), ENSURE_REQUIREMENTS, [plan_id=1809]
                        +- Filter (isnotnull(edge_1#389) AND (edge_1#389 = 7))
                           +- Scan ExistingRDD[edge_1#389,edge_2#390,length#391]


7
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#420)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2044]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#420)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#420]
            +- Project [edge_1#453, edge_2#433, (length#455 + length#434) AS length#449]
               +- SortMergeJoin [edge_2#454], [edge_1#432], Inner
                  :- Sort [edge_2#454 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#454, 200), ENSURE_REQUIREMENTS, [plan_id=2035]
                  :     +- Filter ((edge_2#454 = 8) AND isnotnull(edge_2#454))
                  :        +- Scan ExistingRDD[edge_1#453,edge_2#454,length#455]
                  +- Sort [edge_1#432 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#432, 200), ENSURE_REQUIREMENTS, [plan_id=2036]
                        +- Filter (isnotnull(edge_1#432) AND (edge_1#432 = 8))
                           +- Scan ExistingRDD[edge_1#432,edge_2#433,length#434]


8
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#463)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2271]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#463)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#463]
            +- Project [edge_1#496, edge_2#476, (length#498 + length#477) AS length#492]
               +- SortMergeJoin [edge_2#497], [edge_1#475], Inner
                  :- Sort [edge_2#497 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#497, 200), ENSURE_REQUIREMENTS, [plan_id=2262]
                  :     +- Filter ((edge_2#497 = 9) AND isnotnull(edge_2#497))
                  :        +- Scan ExistingRDD[edge_1#496,edge_2#497,length#498]
                  +- Sort [edge_1#475 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#475, 200), ENSURE_REQUIREMENTS, [plan_id=2263]
                        +- Filter (isnotnull(edge_1#475) AND (edge_1#475 = 9))
                           +- Scan ExistingRDD[edge_1#475,edge_2#476,length#477]


9
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#27)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=201]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#27)])
         +- Union
            :- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#19)])
            :  +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=188]
            :     +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#19)])
            :        +- FileScan csv [edge_1#17,edge_2#18,length#19] Batched: false, DataFilters: [], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_4.csv], PartitionFilters: [], PushedFilters: [], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
            +- Project [edge_1#81, edge_2#59, (length#27 + length#61) AS length#77]
               +- BroadcastHashJoin [edge_2#82], [edge_1#58], Inner, BuildRight, false
                  :- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[min(length#83)])
                  :  +- Exchange hashpartitioning(edge_1#81, edge_2#82, 200), ENSURE_REQUIREMENTS, [plan_id=190]
                  :     +- HashAggregate(keys=[edge_1#81, edge_2#82], functions=[partial_min(length#83)])
                  :        +- Filter ((edge_2#82 = 0) AND isnotnull(edge_2#82))
                  :           +- FileScan csv [edge_1#81,edge_2#82,length#83] Batched: false, DataFilters: [(edge_2#82 = 0), isnotnull(edge_2#82)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_4.csv], PartitionFilters: [], PushedFilters: [EqualTo(edge_2,0), IsNotNull(edge_2)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, true] as bigint)),false), [plan_id=195]
                     +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[min(length#60)])
                        +- Exchange hashpartitioning(edge_1#58, edge_2#59, 200), ENSURE_REQUIREMENTS, [plan_id=192]
                           +- HashAggregate(keys=[edge_1#58, edge_2#59], functions=[partial_min(length#60)])
                              +- Filter (isnotnull(edge_1#58) AND (edge_1#58 = 0))
                                 +- FileScan csv [edge_1#58,edge_2#59,length#60] Batched: false, DataFilters: [isnotnull(edge_1#58), (edge_1#58 = 0)], Format: CSV, Location: InMemoryFileIndex(1 paths)[file:/home/jano1906/studia/bmlhw1/tests/inputs/graph_4.csv], PartitionFilters: [], PushedFilters: [IsNotNull(edge_1), EqualTo(edge_1,0)], ReadSchema: struct<edge_1:int,edge_2:int,length:int>


0
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#92)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=536]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#92)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#92]
            +- Project [edge_1#152, edge_2#132, (length#154 + length#133) AS length#148]
               +- BroadcastHashJoin [edge_2#153], [edge_1#131], Inner, BuildRight, false
                  :- Filter ((edge_2#153 = 1) AND isnotnull(edge_2#153))
                  :  +- Scan ExistingRDD[edge_1#152,edge_2#153,length#154]
                  +- BroadcastExchange HashedRelationBroadcastMode(List(cast(input[0, int, false] as bigint)),false), [plan_id=530]
                     +- Filter (isnotnull(edge_1#131) AND (edge_1#131 = 1))
                        +- Scan ExistingRDD[edge_1#131,edge_2#132,length#133]


1
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#162)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=682]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#162)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#162]
            +- Project [edge_1#195, edge_2#175, (length#197 + length#176) AS length#191]
               +- SortMergeJoin [edge_2#196], [edge_1#174], Inner
                  :- Sort [edge_2#196 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#196, 200), ENSURE_REQUIREMENTS, [plan_id=673]
                  :     +- Filter ((edge_2#196 = 2) AND isnotnull(edge_2#196))
                  :        +- Scan ExistingRDD[edge_1#195,edge_2#196,length#197]
                  +- Sort [edge_1#174 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#174, 200), ENSURE_REQUIREMENTS, [plan_id=674]
                        +- Filter (isnotnull(edge_1#174) AND (edge_1#174 = 2))
                           +- Scan ExistingRDD[edge_1#174,edge_2#175,length#176]


2
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#205)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=909]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#205)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#205]
            +- Project [edge_1#238, edge_2#218, (length#240 + length#219) AS length#234]
               +- SortMergeJoin [edge_2#239], [edge_1#217], Inner
                  :- Sort [edge_2#239 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#239, 200), ENSURE_REQUIREMENTS, [plan_id=900]
                  :     +- Filter ((edge_2#239 = 3) AND isnotnull(edge_2#239))
                  :        +- Scan ExistingRDD[edge_1#238,edge_2#239,length#240]
                  +- Sort [edge_1#217 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#217, 200), ENSURE_REQUIREMENTS, [plan_id=901]
                        +- Filter (isnotnull(edge_1#217) AND (edge_1#217 = 3))
                           +- Scan ExistingRDD[edge_1#217,edge_2#218,length#219]


3
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#248)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1136]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#248)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#248]
            +- Project [edge_1#281, edge_2#261, (length#283 + length#262) AS length#277]
               +- SortMergeJoin [edge_2#282], [edge_1#260], Inner
                  :- Sort [edge_2#282 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#282, 200), ENSURE_REQUIREMENTS, [plan_id=1127]
                  :     +- Filter ((edge_2#282 = 4) AND isnotnull(edge_2#282))
                  :        +- Scan ExistingRDD[edge_1#281,edge_2#282,length#283]
                  +- Sort [edge_1#260 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#260, 200), ENSURE_REQUIREMENTS, [plan_id=1128]
                        +- Filter (isnotnull(edge_1#260) AND (edge_1#260 = 4))
                           +- Scan ExistingRDD[edge_1#260,edge_2#261,length#262]


4
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#291)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1363]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#291)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#291]
            +- Project [edge_1#324, edge_2#304, (length#326 + length#305) AS length#320]
               +- SortMergeJoin [edge_2#325], [edge_1#303], Inner
                  :- Sort [edge_2#325 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#325, 200), ENSURE_REQUIREMENTS, [plan_id=1354]
                  :     +- Filter ((edge_2#325 = 5) AND isnotnull(edge_2#325))
                  :        +- Scan ExistingRDD[edge_1#324,edge_2#325,length#326]
                  +- Sort [edge_1#303 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#303, 200), ENSURE_REQUIREMENTS, [plan_id=1355]
                        +- Filter (isnotnull(edge_1#303) AND (edge_1#303 = 5))
                           +- Scan ExistingRDD[edge_1#303,edge_2#304,length#305]


5
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#334)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1590]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#334)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#334]
            +- Project [edge_1#367, edge_2#347, (length#369 + length#348) AS length#363]
               +- SortMergeJoin [edge_2#368], [edge_1#346], Inner
                  :- Sort [edge_2#368 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#368, 200), ENSURE_REQUIREMENTS, [plan_id=1581]
                  :     +- Filter ((edge_2#368 = 6) AND isnotnull(edge_2#368))
                  :        +- Scan ExistingRDD[edge_1#367,edge_2#368,length#369]
                  +- Sort [edge_1#346 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#346, 200), ENSURE_REQUIREMENTS, [plan_id=1582]
                        +- Filter (isnotnull(edge_1#346) AND (edge_1#346 = 6))
                           +- Scan ExistingRDD[edge_1#346,edge_2#347,length#348]


6
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#377)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=1817]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#377)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#377]
            +- Project [edge_1#410, edge_2#390, (length#412 + length#391) AS length#406]
               +- SortMergeJoin [edge_2#411], [edge_1#389], Inner
                  :- Sort [edge_2#411 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#411, 200), ENSURE_REQUIREMENTS, [plan_id=1808]
                  :     +- Filter ((edge_2#411 = 7) AND isnotnull(edge_2#411))
                  :        +- Scan ExistingRDD[edge_1#410,edge_2#411,length#412]
                  +- Sort [edge_1#389 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#389, 200), ENSURE_REQUIREMENTS, [plan_id=1809]
                        +- Filter (isnotnull(edge_1#389) AND (edge_1#389 = 7))
                           +- Scan ExistingRDD[edge_1#389,edge_2#390,length#391]


7
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#420)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2044]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#420)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#420]
            +- Project [edge_1#453, edge_2#433, (length#455 + length#434) AS length#449]
               +- SortMergeJoin [edge_2#454], [edge_1#432], Inner
                  :- Sort [edge_2#454 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#454, 200), ENSURE_REQUIREMENTS, [plan_id=2035]
                  :     +- Filter ((edge_2#454 = 8) AND isnotnull(edge_2#454))
                  :        +- Scan ExistingRDD[edge_1#453,edge_2#454,length#455]
                  +- Sort [edge_1#432 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#432, 200), ENSURE_REQUIREMENTS, [plan_id=2036]
                        +- Filter (isnotnull(edge_1#432) AND (edge_1#432 = 8))
                           +- Scan ExistingRDD[edge_1#432,edge_2#433,length#434]


8
== Physical Plan ==
AdaptiveSparkPlan isFinalPlan=false
+- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[min(length#463)])
   +- Exchange hashpartitioning(edge_1#17, edge_2#18, 200), ENSURE_REQUIREMENTS, [plan_id=2271]
      +- HashAggregate(keys=[edge_1#17, edge_2#18], functions=[partial_min(length#463)])
         +- Union
            :- Scan ExistingRDD[edge_1#17,edge_2#18,length#463]
            +- Project [edge_1#496, edge_2#476, (length#498 + length#477) AS length#492]
               +- SortMergeJoin [edge_2#497], [edge_1#475], Inner
                  :- Sort [edge_2#497 ASC NULLS FIRST], false, 0
                  :  +- Exchange hashpartitioning(edge_2#497, 200), ENSURE_REQUIREMENTS, [plan_id=2262]
                  :     +- Filter ((edge_2#497 = 9) AND isnotnull(edge_2#497))
                  :        +- Scan ExistingRDD[edge_1#496,edge_2#497,length#498]
                  +- Sort [edge_1#475 ASC NULLS FIRST], false, 0
                     +- Exchange hashpartitioning(edge_1#475, 200), ENSURE_REQUIREMENTS, [plan_id=2263]
                        +- Filter (isnotnull(edge_1#475) AND (edge_1#475 = 9))
                           +- Scan ExistingRDD[edge_1#475,edge_2#476,length#477]


9
[32mOK graph_0.csv[0m
[32mOK graph_1.csv[0m
[32mOK graph_2.csv[0m
[32mOK graph_3.csv[0m
[32mOK graph_4.csv[0m
tests passed: 5 / 5
